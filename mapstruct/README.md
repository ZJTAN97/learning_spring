# Mapstruct Documentation key points

- MapStruct will only create a new mapping method if and only if the source and
  target property are properties of a Bean
  and they themselves are Beans or simple properties. i.e. they are not
  Collection or Map type properties.

# 3.3 Adding Custom Methods to mappers

- used for cases where it is required to manually implement a specific
  mapping from one type to another which cannot be generated by mapstruct

```
@Mapper
public interface CarMapper {

    @Mapping(...)
    ...
    CarDto carToCarDto(Car car);

    default PersonDto personToPersonDto(Person person) {
        //hand-written mapping logic
    }
}
```

<br>

# 3.4 Mapping methods with several source parameters

```
@Mapper
public interface AddressMapper {

    @Mapping(target = "description", source = "person.description")
    @Mapping(target = "houseNumber", source = "address.houseNo")
    DeliveryAddressDto personAndAddressToDeliveryAddressDto(Person person, Address address);
}
```

- In case several source objects define a property with the same name, the
  source parameter from which to retrieve the
  property must be specified using the @Mapping annotation as shown for the
  description property in the example. An
  error will be raised when such an ambiguity is not resolved.

<br>

# 3.5 Mapping nested bean properties to current target

If you donâ€™t want explicitly name all properties from nested source bean, you
can use `.` as target. This will tell
MapStruct to map every property from source bean to target object. The following
shows an example:

```

 @Mapper
 public interface CustomerMapper {

     @Mapping( target = "name", source = "record.name" )
     @Mapping( target = ".", source = "record" )
     @Mapping( target = ".", source = "account" )
     Customer customerDtoToCustomer(CustomerDto customerDto);
 }

```

<br>

# 3.6 Updating existing bean instances

```

@Mapper
public interface CarMapper {

    void updateCarFromDto(CarDto carDto, @MappingTarget Car car);
}

```

- used when you need mappings which do not create a new instance of the
  target type but instead update an existing instance of that type.
- The generated code of the `updateCarFromDto()` method will update the
  passed `Car` instance with the properties from the given `CarDto` object.

<br>

# 10.4 Subclass Mapping

- When both input and result types have inheritance relation, you want the
  correct specialization to be mapped

```
@Mapper
public interface FruitMapper {

    @SubclassMapping( source = AppleDto.class, target = Apple.class )
    @SubclassMapping( source = BananaDto.class, target = Banana.class )
    Fruit map( FruitDto source );

}
```

- If you would just use a normal mapping both the AppleDto and the BananaDto
  would be made into a Fruit object, instead of an Apple and a Banana object
- By using the subclass mapping an AppleDtoToApple mapping will be used for
  AppleDto objects, and an BananaDtoToBanana mapping will be used for BananaDto
  objects. If you try to map a GrapeDto it would still turn it into a Fruit.

# 10.11 Conditional Mapping

- a type of Source presence checking
- allows users to write custom condition methods that will be invoked to
  check if a property needs to be mapped or not.

```
@Mapper
public interface CarMapper {

    CarDto carToCarDto(Car car);

    @Condition
    default boolean isNotEmpty(String value) {
        return value != null && !value.isEmpty();
    }
}
```
https://mapstruct.org/documentation/stable/reference/html/
